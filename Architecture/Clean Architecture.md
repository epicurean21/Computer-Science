# Clean Architecture

[TOC]

## Chapter 01. 계층형 아키텍처의 문제는 무엇일까?

![layerArchitecture](./img/layerArchitecture.png)

우선 계층 (layer) 아키택처란 무엇인가. <u>웹 계층, 도메인 계층, 영속성 계층으로 구성된 전통적인 웹 애플리케이션 구조이다.</u>

- 웹 계층에서 요층을 받아 도메인 또는 비즈니스 계층의 서비스로 요청을 보낸다.
- 서비스에서는 비즈니스 로직을 수행하고, 영속성 계층의 컴포넌트를 호출한다.
- <u>특정한 계층에서는 **같은 계층에** 있는 컴포넌트나 **하위에 있는 계층에만 접근이** 가능하다.</u>
  - 요청은 외부에서 request가 web layer [controller]로 들어오면, 서비스로 business logic 처리를 위임한다. 서비스 레이어에서는 데이터 처리를 위한 영속성 레이어를 호출한다.
- 하지만 이러한 계층형 아키텍처에는 유지보수에 실패하는 함정들이 다수 있다.



### 계층형 아키텍처의 함정

> 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

- 애플리케이션의 use case 작성시에, 도메인 로직보다 영속성 계층을 먼저 구현하고 이를 토대로 도메린 로직을 구현한다.
  - 이는, 의존성의 방향에 맞게 구현한 것이다.
- ORM (객체 관계 매핑) 프레임워크를 사용하는 경우, 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.
- 비즈니스 관점에서는 도메인 로직이 애플리케이션의 핵심이지만, 개발자 입장으로서 도메인 로직이 아닌, 데이터베이스를 우선적으로 신경쓰게된다.

- 도메인 계층과, 데이터베이스간의 강결합이 발생할 가능성이 농후하다.



> 지름길을 택하기 쉬워진다.







## Chapter 02. 의존성 역전하기



### SOLID 원칙

- S [Single Responsibility Principal]: 단일 책임 원칙
  - 모든 클래스는 각각 하나의 책임만 가져야 한다. 즉 클래스는 그 책임을 캡슐화 해야함.
- O [Open closed principle]: 개방 폐쇄 원칙
  - 확장에는 Open, 수정에는 Closed. 기존의 코드는 변경하지 않으면서 기능을 추가할 수 있도록 설계한다
- L [Liskov Substitution Principle]: 리스코프 치환 원칙
  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다. 
- I [Interface Segregation Principle]: 인터페이스 분리 원칙
  - 한 클래스에는 자신이 사용하지않는 인터페이스는 구현하지 말아야 한다.
- D [Dependency Inversion Principle]: 의존성 역전 원칙
  - 클라이언트는 추상화 (인터페이스)에 의존해야 하며, 구체화에 의존해서는 안된다.



### 단일 책임 원칙 [Single Responsibility Principle]

- 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다
- **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다**

<img src="./img/solid.jpeg" alt="solid" style="zoom:50%;" /> 

- 각 컴포넌트의 의존성은 이 컴포넌트를 변경하는 이유 하나씩에 해당한다.
- 전이 의존성인 경우도 해당 (점선 부분)



### 의존성 역전 원칙 [Dependency Inversion Principle]

- **코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다**
- 계층형 아키텍처에서 항상 아래 계층으로 향하는 의존성을 반대로 역전
  - 고수준에서 변경할 일이 더 많으므로 도메인 계층 변경 → 영속성 계층 변경 → 영속성 계층에 의존하는 잠재적인 도메인 계층 변경이 발생
  - 영속성 코드가 바뀐다고 도메인 계층을 바꾸고 싶지 않음
  - 의존성을 반대로 역전시켜 도메인 계층의 영속성 계층 의존성을 제거

Before:

<img src="./img/dip1.jpeg" alt="dip1" style="zoom:50%;" /> 

After:

 <img src="./img/dip2.jpeg" alt="dip1" style="zoom:50%;" />

- 영속성, 도메인 계층에 각각 엔티티가 존재
- 도메인 계층에 리포지토리 인터페이스를 만들고, 영속성 계층에서 구현체를 만듬
- 도메인 로직을 영속성 코드의 의존성으로부터 해방



### 클린 아키텍처

- 특징
  - 클린 아키텍처에서는 도메인 코드에서 바깥으로 향하는 의존성이 없음
  - 의존성 역전 원칙으로 계층간 모든 의존성이 안쪽으로 향함
  - 핵심에 도메인 엔티티, 유스케이스는 계층형 아키텍처에서 서비스에 해당하는 부분
  - 유스케이스는 더 세분화되어 계층형 아키텍처의 넓은 서비스 문제 회피
  - 코어 주변에 비즈니스 로직을 지원하는 다른 컴포넌트 (웹, UI)가 존재

- 장점
  - 도메인 코드에서 어떤 영속성, UI 프레임워크에 의존성이 없기 때문에 프레임워크 특화된 코드가 존재하지 않고 비즈니스 로직에 집중 가능
  - 도메인 코드를 자유롭게 모델링 하며 DDD를 가장 순수한 형태로 적용해 볼수도 있음
- 단점
  - 도메인 계층과 외부 계층을 철저하게 분리해야 하므로 각 계층에서 엔티티 모델을 유지보수 해야함
  - ORM 계층 엔티티, 도메인 계층 엔티티를 각각 만들고 계층 엔티티간의 변환이 필요 (하지만 바람직한 일)



### 핵사고날 아키텍처 (육각형 아키텍처)

![hexagonal](./img/hexagonal.jpg)

- 클린 아키텍처의 구체적 형태
  - 육각형
    - 어플리케이션 코어
    - 도메인 엔티티와 이와 상호작용하는 유즈케이스
  - 어댑터
    - 어플리케이션과 다른 시스템(웹, 데이터베이스..) 간의 번역을 담당
    - 포트를 통해 어플리케이션과 상호작용
  - 포트
    - 육각형의 경계에 존재
    - 외부와 상호작용하는 인터페이스
  - 유즈케이스
    - 도메인 로직
    - 엔티티와 상호작용
  - 도메인 엔티티

- 어댑터와 포트를 통해 통해 외부 시스템과 상호작용
  - 어플리케이션을 호출하는 어댑터 (웹)
    - 입력 포트를 사용
      - 유스 케이스에 의해 구현
  - 어플리케이션에 의해 주도되는 어댑터 (데이터베이스)
    - 출력 포트를 사용
      - 어댑터에 의해 구현
- 포트와 어댑터 아키텍처라고도 함



## Chapter 03. 코드 구성하기



### 계층으로 구성하기

![layer](./img/layer.jpg)

- 웹, 도메인, 영속성 계층 각가 web, domain, persistence package로 구성
- DIP 원칙을 적용하여 domain 패키지에는 도메인 코드만 존재
  - AccountRepository는 interface로 구성
  - persistence package에서 AccountRepositoryImpl class 배치(domain inteface 구현체)



#### 이게 최적화가 아닌 이유

- 기능 조각(functional slice) 또는 특성(feature)을 구분할 수 있는 패키지 경계가 없음
  - 사용자 관리 기능 추가하는 경우, 각 layer마다 다음과 같이 추가될 수 있음
    - web : UserController
    - domain : UserService, UserRepository, User
    - persistence : UserRepositoryImpl
  - Account, User와 같이 서로 연관되어 있지 않은 클래스들이 묶이는 상황 발생
- 어떤 유즈케이스가 있는지 파악이 불가능
  - Layer에 있는 클래스를 직접적으로 확인해야 어떤 유즈케이스가 구현되어 있는지 파악 가능
- 패키지 구조만으로 우리가 목표로 하는 아키텍처(육각형 아키텍처) 파악이 불가능
  - Incoming port / outgoing port를 직접적으로 확인할 수 없음 (코드를 뒤져야함)



### 기능으로 구성하기

![serviceLAyer](./img/serviceLAyer.jpg) 



- 계좌와 관련된 모든 코들를 account package에 넣고, 계층 패키지를 모두 없앰
- account package와 마찬가지로 기능을 묶을 때는 그와 같은 레벨의 package를 생성하여 추가
- 외부에서 접근이 안되는 클래스들은 package-private(default) 접근 수준을 이용하여 패키지간의 경계를 강화

- SendMoneyService : 송금하기 유즈케이스를 구현한 코드. 클래스명에서 어떤 일을 하는 알 수 있기 때문에, Uncle Bob은 이런 것을 소리치는 아키텍처(Screaming architecture)라고 명명.



### 표현력 있는 패키지 구조 (목표)

![hexagonalArchitecture](./img/hexagonalArchitecture.jpg)

- 육각형 아키텍쳐에서 핵심 요소 : 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터
- account : Account와 관련한 유스케이스를 구현한 모듈 패키지
- domain : 도메인 모델이 속해있는 패키지
- application : 도메인 모델을 둘러싼 서비스 계층
  - port : 외부와 통신하기 위한 인터페이스 패키지 (의존성)
    - in : 외부(웹등)에서 서비스 요청을 하기 위한 인터페이스. 서비스 계층에서 해당 인터페이스를 구현함
    - out : 서비스에서 외부(영속성)에 요청을 하기 위한 인터페이스. adapter에서 해당 인터페이스를 구현함
- adapter
  - in : 애플리케이션 계층의 인커밍 포트를 호출하는 패키지
  - out : 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 패키지

#### 장점

- 패키지 구조 자체가 육각형 아키텍쳐를 그대로 반영하는 구조
  - 아키텍쳐-코드 갭(architecture-code gap), 모델-코드 갭(model-code gap)이 거의 없는 구조
  - 기능 작업시, 패키지 선택 장애가 육각형 아키텍쳐에서는 거의 없음
- package간에 불필요한 접근을 막을 수 있는 구조
  - adapter : application/port를 통해서만 호출되는 구조 -> package-private 접근 수준으로 막을 수 있음 (IDE단에서 잘못된 접근을 통제 가능)
  - application, domain
    - port : adapter에서 접근 가능해야함 -> public
    - domain : adapter에서 접근 가능해야함 -> public
    - service : adapter에서 직접 접근할 필요가 없음 -> package-private
- adapter 내부 변경은 adapater 내부에서 처리가능
  - SQL -> Key-Value DB로 변경하는 경우, adapter내에서 아웃고잉 port 인터페이스를 구현하면 끝
- DDD에 직접적으로 대응 가능
  - account : 다른 바운디드 컨텍스트와 통신할 전용 진입점과 출구(포트)를 포함하는 바운디드 컨텍스트임
  - \* bounded context : 어떤 하나의 도메인 모델이 적용되는 범위를 나타냄



### 의존성 주입의 역할

![di](./img/di.jpg) 

- 클린 아키텍쳐의 가장 본질적인 요소 : 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 점 (2장 설명)
- 인커밍 어댑터 : adapter와 도메인 코드 간의 의존성 방향이 동일함. adapter -> application을 호출
- 아웃고잉 어댑터 : 도메인 코드 -> adapter 의존성이 있기 때문에 의존성 역전 원칙을 이용해야함
- 의존성 역전 방법 : application 계층에서 port 인터페이스를 만들고, adapter가 해당 인터페이스를 구현
- 포트 인터페이스를 구현한 실제 객체를 누가 어플리케이션 계층에 제공해야하나?? -> 의존성 주입
- 의존성 주입 : 모든 계층에 의존성을 가진 중립적인 컴포넌트 도입 (스프링) 
  - 역할 : 대부분의 클래스를 초기화하는 역할을 맡음







## Chapter 05. 웹 어댑터 구현하기

> 웹 인터페이스: 웹 브라우저를 통해 상호작용하는 UI나, 외부 애플리케이션을 호출하며 상호작용하는 HTTP API 등을 표현한다.
>
> 웹 인터페이스를 제공하는 **어댑터의** 구현 방법에 대해서 알아보자.



### 의존성 역전

![WebAdapter](./img/WebAdapter.png)

- 인커밍 어댑터 (좌) 는 애플리케이션 서비스 (우) 에 의해 구현된 전용 포트 (중) 를 통해 애플리케이션 계층과 통신한다.

#### 웹 어댑터는 **주도하는**, 혹은 **인커밍** 어댑터이다.

- 즉, 외부 요청을 받아 애플리케이션 코어를 **호출하고 어떤 작업을 해야하는지 알려준다.**

- 애플리케이션 계층에서 웹 어댑터가 통신할 수 있는 port 들을 구현하고, 웹 어댑터는 이 포트들을 호출할 수 있다. 

**의존성 역전 원칙이 적용되어있는걸 볼 수 있다.**



![di_2](./img/dip.png)



제어 흐름이 왼쪽에서 오른쪽으로 흐르는걸 알 수 있다. 그렇기 때문에 유스케이스 (서비스)를 직접 호출할 수 있다.



##### 그렇다면 왜 어댑터와 유스케이스 사이에 포트라는 간접 계층이 필요할까?

- 애플리케이션 코어가 외부와 통신하는 명세가 바로 **포트**이다.

  - 즉, 외부와 어떤 통신이 일어나는지 정확하게 알 수 있다.

- 애플리케이션 코어에서 실시간 데이터를 어뎁터에 보내야 한다면?

  - 포트가 반드시 필요하다 !

  ![outgoingPort](./img/outgoingPort.png)

  - 의존성에 올바른 방향을 유지하기 위해 아웃고잉 포트를 통과해야한다 !
  - 어댑터가 한 인커밍 **어댑터 / 아웃커밍 어댑터 두 가지 역할을 할 수도있다**.



### 웹 어댑터의 책임

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사 - 인증/인가
3. 입력 유효성 검증 - Validation
4. 입력을 유스케이스 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스 호출을 HTTP로 매핑
7. HTTP 응답을 반환

웹 어댑터에게 꽤나 많은 책임이 주어지는걸 볼 수 있다.

- 하지만 이 책임들은 애플리케이션 계층이 신경쓰면 안되는 것들이다.
- 특정 HTTP를 다루는 것을 애플리케이션 계층이 알게된다면 ?
  - HTTP를 사용하지 않는 동일한 도메인 로직을 새롭게 적용시킬 수 없다.



입력의 **유효성 검증은 유스케이스 입력 모델의 책임이다?**

- 유스케이스의 입력 모델 검증과는 다르다. 웹 어댑터의 입력모델에 대한 얘기이다.
- 웹 어댑터 입력 모델 → 유스케이스 입력 모델 변환할 수 있는지를 검증해야한다.
  - 변환에 방해가 있는게 바로 검증 에러라고 할 수 있다.





### 컨트롤러 나누기

- 웹 어댑터는 한 개 이상의 클래스로 구성할 수 있다.
- 컨트롤러는 **적은 것 보다는 많은 게 낫다.**
  - 각 컨트롤러가 가능한 좁고 외부와 적게 공유하는 웹 어댑터 조각을 구현해야한다.



기존 우리가 예상하는 Controller를 보자

```java
@RestController
@RequiredArgsConstructor
public class AccountController {
    private final GetAccountBalanceQuery getAccountBalanceQuery;
    private final ListAccountQuery listAccountQuery;
    private final LoadAccountQuery loadAccountQuery;

    @GetMapping("/accounts")
    List<AccountResource> listAccounts() {
        ...
    }
    
    @GetMapping("/accounts/id")
    AccountResource getAccount(@PathVariable("accountId") Long accountId) {
        ...
    }
    
    @PostMapping("/accounts")
    AccountResource createAccount(@RequestBody AccountResource account) {
        ...
    }
    
    ...
}
```

계좌 (account)의 리소스 관련된 것들이 하나의 클래스에 모여저 있다. 이것들의 **단점을** 알아보자.



##### 무엇이 단점일까?

- 클래스마다 코드는 적을수록 좋다 !
  - 아무리 메서드가 분리되어 있어도 한 번에 파악하기 힘들다.
- 테스트 코드를 만들기 힘들다
  - 클래스가 작을수록 특정 프로덕션 코드에 해당하는 테스트코드를 찾기 힘들다.

- (중요) **데이터 구조의 재활용을 촉진하게 된다.**
  - 예시에서 AccountResource 모델 클래스를 많은 메소드에서 활용한다. 
    - AccountResource 가 모든 데이터를 담고 있다고하자.
    - 그리고 Account와 User가 1:N 관계라고 해보자
  - 계좌 생성시 User 정보가 필요할까? 반환값에 포함시켜야 할까? 
    - 개발을 진행하며 마딱드릴 수 있다.



컨트롤러는 각각 자체의 모델을 갖고 있을 수 있게 한다면

- 자체 모델 클래스는 private으로 선언해서 다른곳에서의 **재사용을 막을 수 있다.**

- 결국 필드의 절반 이상이 필요없다는걸 깨닫게 되고, 컨트롤러에 맞는 모델을 만들게 될 수 있다.
  - 결국은 더 작은 (특정한) 부분을 담당하는 모델을 만들게 된다.



#### 컨트롤러 & 서비스 Naming

- 가능한 메소드 & 클래스명은 유스케이스를 반영해서 지어야한다.
  - CreateAccount 보다 RegisterAccount가 나을 수 있다.
    - 계좌 생성은 계좌를 등록하는 방법 뿐.. 생성보다는 register가 나을수있다.



### 유지보수가 가능한 소프트웨어

웹 컨트롤러를 나눌 때는 모델을 **공유하지 않는** 작은 클래스들을 만들도록 노력하자.

작은 클래스은

- 파악하기 쉽다
- 테스트하기 쉽다
- 동시 작업을 지원한다





