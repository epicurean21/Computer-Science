# Clean Architecture

[TOC]

## Chapter 01. 계층형 아키텍처의 문제는 무엇일까?

![layerArchitecture](./img/layerArchitecture.png)

우선 계층 (layer) 아키택처란 무엇인가. <u>웹 계층, 도메인 계층, 영속성 계층으로 구성된 전통적인 웹 애플리케이션 구조이다.</u>

- 웹 계층에서 요층을 받아 도메인 또는 비즈니스 계층의 서비스로 요청을 보낸다.
- 서비스에서는 비즈니스 로직을 수행하고, 영속성 계층의 컴포넌트를 호출한다.
- <u>특정한 계층에서는 **같은 계층에** 있는 컴포넌트나 **하위에 있는 계층에만 접근이** 가능하다.</u>
  - 요청은 외부에서 request가 web layer [controller]로 들어오면, 서비스로 business logic 처리를 위임한다. 서비스 레이어에서는 데이터 처리를 위한 영속성 레이어를 호출한다.
- 하지만 이러한 계층형 아키텍처에는 유지보수에 실패하는 함정들이 다수 있다.



### 계층형 아키텍처의 함정

> 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

- 애플리케이션의 use case 작성시에, 도메인 로직보다 영속성 계층을 먼저 구현하고 이를 토대로 도메린 로직을 구현한다.
  - 이는, 의존성의 방향에 맞게 구현한 것이다.
- ORM (객체 관계 매핑) 프레임워크를 사용하는 경우, 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.
- 비즈니스 관점에서는 도메인 로직이 애플리케이션의 핵심이지만, 개발자 입장으로서 도메인 로직이 아닌, 데이터베이스를 우선적으로 신경쓰게된다.

- 도메인 계층과, 데이터베이스간의 강결합이 발생할 가능성이 농후하다.



> 지름길을 택하기 쉬워진다.







## Chapter 02. 의존성 역전하기



### SOLID 원칙

- S [Single Responsibility Principal]: 단일 책임 원칙
  - 모든 클래스는 각각 하나의 책임만 가져야 한다. 즉 클래스는 그 책임을 캡슐화 해야함.
- O [Open closed principle]: 개방 폐쇄 원칙
  - 확장에는 Open, 수정에는 Closed. 기존의 코드는 변경하지 않으면서 기능을 추가할 수 있도록 설계한다
- L [Liskov Substitution Principle]: 리스코프 치환 원칙
  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다. 
- I [Interface Segregation Principle]: 인터페이스 분리 원칙
  - 한 클래스에는 자신이 사용하지않는 인터페이스는 구현하지 말아야 한다.
- D [Dependency Inversion Principle]: 의존성 역전 원칙
  - 클라이언트는 추상화 (인터페이스)에 의존해야 하며, 구체화에 의존해서는 안된다.



### 단일 책임 원칙 [Single Responsibility Principle]

- 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다
- **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다**

<img src="./img/solid.jpeg" alt="solid" style="zoom:50%;" /> 

- 각 컴포넌트의 의존성은 이 컴포넌트를 변경하는 이유 하나씩에 해당한다.
- 전이 의존성인 경우도 해당 (점선 부분)



### 의존성 역전 원칙 [Dependency Inversion Principle]

- **코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다**
- 계층형 아키텍처에서 항상 아래 계층으로 향하는 의존성을 반대로 역전
  - 고수준에서 변경할 일이 더 많으므로 도메인 계층 변경 → 영속성 계층 변경 → 영속성 계층에 의존하는 잠재적인 도메인 계층 변경이 발생
  - 영속성 코드가 바뀐다고 도메인 계층을 바꾸고 싶지 않음
  - 의존성을 반대로 역전시켜 도메인 계층의 영속성 계층 의존성을 제거

Before:

<img src="./img/dip1.jpeg" alt="dip1" style="zoom:50%;" /> 

After:

 <img src="./img/dip2.jpeg" alt="dip1" style="zoom:50%;" />

- 영속성, 도메인 계층에 각각 엔티티가 존재
- 도메인 계층에 리포지토리 인터페이스를 만들고, 영속성 계층에서 구현체를 만듬
- 도메인 로직을 영속성 코드의 의존성으로부터 해방



### 클린 아키텍처

- 특징
  - 클린 아키텍처에서는 도메인 코드에서 바깥으로 향하는 의존성이 없음
  - 의존성 역전 원칙으로 계층간 모든 의존성이 안쪽으로 향함
  - 핵심에 도메인 엔티티, 유스케이스는 계층형 아키텍처에서 서비스에 해당하는 부분
  - 유스케이스는 더 세분화되어 계층형 아키텍처의 넓은 서비스 문제 회피
  - 코어 주변에 비즈니스 로직을 지원하는 다른 컴포넌트 (웹, UI)가 존재

- 장점
  - 도메인 코드에서 어떤 영속성, UI 프레임워크에 의존성이 없기 때문에 프레임워크 특화된 코드가 존재하지 않고 비즈니스 로직에 집중 가능
  - 도메인 코드를 자유롭게 모델링 하며 DDD를 가장 순수한 형태로 적용해 볼수도 있음
- 단점
  - 도메인 계층과 외부 계층을 철저하게 분리해야 하므로 각 계층에서 엔티티 모델을 유지보수 해야함
  - ORM 계층 엔티티, 도메인 계층 엔티티를 각각 만들고 계층 엔티티간의 변환이 필요 (하지만 바람직한 일)



### 핵사고날 아키텍처 (육각형 아키텍처)

![hexagonal](./img/hexagonal.jpg)

- 클린 아키텍처의 구체적 형태
  - 육각형
    - 어플리케이션 코어
    - 도메인 엔티티와 이와 상호작용하는 유즈케이스
  - 어댑터
    - 어플리케이션과 다른 시스템(웹, 데이터베이스..) 간의 번역을 담당
    - 포트를 통해 어플리케이션과 상호작용
  - 포트
    - 육각형의 경계에 존재
    - 외부와 상호작용하는 인터페이스
  - 유즈케이스
    - 도메인 로직
    - 엔티티와 상호작용
  - 도메인 엔티티

- 어댑터와 포트를 통해 통해 외부 시스템과 상호작용
  - 어플리케이션을 호출하는 어댑터 (웹)
    - 입력 포트를 사용
      - 유스 케이스에 의해 구현
  - 어플리케이션에 의해 주도되는 어댑터 (데이터베이스)
    - 출력 포트를 사용
      - 어댑터에 의해 구현
- 포트와 어댑터 아키텍처라고도 함



## Chapter 03. 코드 구성하기



## Chapter 05. 웹 어댑터 구현하기
